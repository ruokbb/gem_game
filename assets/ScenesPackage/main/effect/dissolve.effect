CCEffect %{
  techniques:
  - name: base
    passes:
    - vert: vs:main
      frag: fs:main
      blendState:
        targets:
        - blend: true
      depthStencilState:
        depthTest: false
        depthWrite: false
      rasterizerState:
        cullMode: none
  properties:
    _MainTexture: {type: 2d, value: white}
    dissolveDirection: {type: vector, value: [0, 0], displayName: 渐隐方向}
    edgeSharpness: {type: float, value: 1, editor: {displayName: 边缘锐利度, step: 0.1}}
    dissolveAmount: {type: float, value: 0, editor: {range: [0, 1], displayName: 溶解比例 }}
    randomDissolve: {type: int, value: 0, editor: {displayName: 是否随机溶解}} 
    seed: {type: float, value: 0, editor: {displayName: 随机种子}}
%}

CCProgram vs %{
  precision highp float;

  #include <cc-global>
  #include <cc-local>
  #include <shadow-prepass>
  #include <shadow-cascades>
  #include <instance>

  in vec2 a_texCoord;
  in vec4 a_color;

  out vec2 v_texCoord;
  out vec4 v_color;

  void main () {
    vec4 pos = vec4(a_position, 1);
    #if CC_USE_MODEL_TRANSFORM
      pos = cc_matModel * pos;
    #endif
    float alignment = cc_matProj[0].z;
    float flippedTexCoord = (cc_mirrorFlag & CC_FLIP_U_TEXCOORD) == 0 ? a_texCoord.x : 1.0 - a_texCoord.x; 
    pos.xy += cc_packingWidth * vec2((alignment - flippedTexCoord) * cc_matProj[2].z, 0);

    v_texCoord = a_texCoord;
    v_color = a_color;

    #pragma CCEX_SHADOWBEFOREPASS
    #pragma CCEX_SPHEREINST_SHADECLACC
    gl_Position = cc_matProj * pos;
  }
}%

CCProgram fs %{
  precision highp float;

  #include <alpha-test>
  #include <shadow-decode>

  uniform sampler2D _MainTexture;
  uniform vec2 dissolveDirection;
  uniform float edgeSharpness;
  uniform float dissolveAmount;
  uniform int randomDissolve;
  uniform float seed;

  in vec2 v_texCoord;
  in vec4 v_color;

  out vec4 o_color;

  void main () {

    vec4 col = texture(_MainTexture, v_texCoord) * v_color;
    float value = dot(dissolveDirection, v_texCoord * 2.0);

    if (randomDissolve == 1) { 
      vec3 randomPos = vec3(v_texCoord, seed);
      float noise = fract(sin(dot(randomPos, vec3(12.9898, 78.233, 122.993))) * 43758.5453);
      value = (value + noise) * 0.5;
    }
    
    float dissolve = smoothstep(dissolveAmount, dissolveAmount + edgeSharpness, value);

    col.a *= dissolve;
    col.rgb *= col.a;

    o_color = col;
    doAlphaDiscard();
  }
}%